/*
이전 수업 내용 :
·생성자는 함수이고 디폴트값을 설정해줘야 NULL값이 없어진다.
·'이니셜라이즈' 는 C++의 전형적인 특징이고 대입문을 괄호 안에 넣어서 사용 가능. ex) n=n1 -> n(n1)
·참조자(Reference)의 특징은 선언과 동시에 초기화되어야 함.
·디폴트 생성자는 클래스의 동일한 생성자명을 설정 안 해도 컴퓨터가 알아서 만들어줌. but 불안정해서 사용 권장X
· 소멸자는 생성자와 상반되는 개념.
    - C++ 은 동적할당, 클래스 내부에서도 new 함수를 자주 사용함.(malloc과 같은 개념)
    - Heap 영역에 할당된 메모리를 해제해줌.
    - 자동으로 생성되지만 클래스 안에서 new 함수를 사용할 경우 반드시 소멸자를 작성해줘야 함.

오늘 수업 내용 :
- 객체 배열
·객체를 담을 변수를 나열한 것. (실배열)
·객체의 크기는 클래스 내의 변수 크기들의 합. sizeof 함수를 통해 확인 가능.
·객체화 되어 있다 = 초기화되어 호출가능한 상태

- 객체 '포인터' 배열
·주소(포인터)의 배열(주소 : 8바이트)
·각각 주소 안에 실값이 있는지 모르기 때문에 new함수를 이용해서 값을 채워줌.
ex)
Person *arr[3];
arr[0] = new Person(name, age);
arr[1] = new Person(name, age);
arr[2] = new Person(name, age);

- this포인터의 이해
·클래스 내부에서 사용. 나 자신(self)을 가리키는 포인터
·self-reference의 반환

- 복사생성자
·Point p4 = p3, p5(p2);

- 상속
·접근제어 지시자 중 private, public 말고 'protected' 을 사용함.
·하위 클래스에서 생성자 형성할 때 반드시 상위 클래스를 호출해야 한다.
·하위 클래스에서는 상위 클래스의 접근가능한 맴버변수도 사용 가능하다.
·상속의 개념의 정확하게 확립할 것.
곁가지 :
·a라는 객체의 변수를 들어갈 때 객체가 실변수일 때 '.'을 찍고 포인터일 때 '->' 사용

*/


#include <iostream>

int main()
{
    std::cout << "Hello World!\n";
}